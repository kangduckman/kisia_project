# -*- coding: utf-8 -*-
"""cermine_referece_deletion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UXPrKyIe87N_Yu36ivfWDy__0r2xe-UB
"""

!pip install arxiv2bib>=1.0.7
!pip install bibtexparser>=0.6.2
!pip install isbnlib>=3.5.7
!pip install requests>=2.9.1
!pip install PySocks>=1.5.6
!pip install PyPDF2>=1.25.1

!git clone https://github.com/kermitt2/libbmc.git

!pip install fitz

!pip install PyMuPDF

!pip install fpdf

import sys
sys.path.append('/content/libbmc')

#This file contains all the functions to extract DOIs of citations from
#PDF files.

import os
import subprocess
import xml.etree.ElementTree as ET
import re
import requests

from requests.exceptions import RequestException

from libbmc import tools
from libbmc.citations import plaintext


CERMINE_BASE_URL = "http://cermine.ceon.pl/"
SCRIPT_DIR = os.path.dirname(os.path.realpath('/content/drive/MyDrive/2407.19153v1.pdf'))


def cermine(pdf_file, force_api=False, override_local=None):
    """
    Run `CERMINE <https://github.com/CeON/CERMINE>`_ to extract metadata from \
            the given PDF file, to retrieve citations (and more) from the \
            provided PDF file. This function returns the raw output of \
            CERMINE call.

    .. note::

        Try to use a local CERMINE JAR file, and falls back to using the API. \
                JAR file is expected to be found in \
                ``libbmc/external/cermine.jar``. You can override this using \
                the ``override_local`` parameter.

    .. note::

        CERMINE JAR file can be found at \
                `<http://maven.icm.edu.pl/artifactory/simple/kdd-releases/pl/edu/icm/cermine/cermine-impl/>`_.

    .. note::

        This fallback using the \
                `CERMINE API <http://cermine.ceon.pl/about.html>`_, and \
                hence, uploads the PDF file (so uses network). Check out \
                the CERMINE API terms.

    :param pdf_file: Path to the PDF file to handle.
    :param force_api: Force the use of the Cermine API \
            (and do not try to use a local JAR file). Defaults to ``False``.
    :param override_local: Use this specific JAR file, instead of the one at \
            the default location (``libbmc/external/cermine.jar``).
    :returns: Raw output from CERMINE API or ``None`` if an error occurred. \
            No post-processing is done.
    """
    try:
        # Check if we want to load the local JAR from a specific path
        local = override_local
        # Else, try to stat the JAR file at the expected local path
        if (local is None) and (not force_api):
            if os.path.isfile(os.path.join(SCRIPT_DIR,
                                           "../external/cermine.jar")):
                local = os.path.join(SCRIPT_DIR,
                                     "../external/cermine.jar")

        # If we want to force the API use, or we could not get a local JAR
        if force_api or (local is None):
            print("Using API")
            with open(pdf_file, "rb") as fh:
                # Query the API
                request = requests.post(
                    CERMINE_BASE_URL + "extract.do",
                    headers={"Content-Type": "application/binary"},
                    files={"file": fh}
                )
                return request.text
        # Else, use the local JAR file
        else:
            return subprocess.check_output([
                "java",
                "-cp", local,
                "pl.edu.icm.cermine.PdfNLMContentExtractor",
                "-path", pdf_file, '-outputs', 'jats,text,zones,trueviz,images']).decode("utf-8")
    except (RequestException,
            subprocess.CalledProcessError,
            FileNotFoundError):
        # In case of any error, return None
        return None


def cermine_dois(pdf_file, force_api=False, override_local=None):
    """
    Run `CERMINE <https://github.com/CeON/CERMINE>`_ to extract DOIs of cited \
            papers from a PDF file.

    .. note::

        Try to use a local CERMINE JAR file, and falls back to using the API. \
                JAR file is expected to be found in \
                ``libbmc/external/cermine.jar``. You can override this using \
                the ``override_local`` parameter.

    .. note::

        CERMINE JAR file can be found at \
                `<http://maven.icm.edu.pl/artifactory/simple/kdd-releases/pl/edu/icm/cermine/cermine-impl/>`_.

    .. note::

        This fallback using the \
                `CERMINE API <http://cermine.ceon.pl/about.html>`_, and \
                hence, uploads the PDF file (so uses network). Check out \
                the CERMINE API terms.

    .. note::

        This function uses CERMINE to extract references from the paper, and \
                try to match them on Crossref to get DOIs.

    :param pdf_file: Path to the PDF file to handle.
    :param force_api: Force the use of the Cermine API \
            (and do not try to use a local JAR file). Defaults to ``False``.
    :param override_local: Use this specific JAR file, instead of the one at \
            the default location (``libbmc/external/cermine.jar``).
    :returns: A dict of cleaned plaintext citations and their associated DOI.
    """
    # TODO:
    #    * Do not convert to plain text, but use the extra metadata from
    #      CERMINE
    # Call CERMINE on the PDF file
    cermine_output = cermine(pdf_file, force_api, override_local)
    # Parse the resulting XML
    root = ET.fromstring(cermine_output)
    plaintext_references = [
        # Remove extra whitespaces
        tools.clean_whitespaces(
            # Convert XML element to string, discarding any leading "[n]"
            ET.tostring(e, method="text").decode("utf-8").replace(e.text, ""))
        for e in root.iter("mixed-citation")]
    # Call the plaintext methods to fetch DOIs
    return plaintext.get_cited_dois(plaintext_references)

'''import fitz
import re
from fpdf import FPDF

class PDF(FPDF):
    def __init__(self):
        super().__init__()
        self.add_page()
        self.set_font("Arial", size = 12)

    def add_text(self, text):
        self.multi_cell(0, 10, text)

def string_to_pdf(input_text, pdf_filename):

    pdf = PDF()

    pdf.add_text(input_text)

    pdf.output(pdf_filename)

def extract_text_from_pdf(pdf_path):
    doc = fitz.open(pdf_path)
    text = ""
    for page in doc:
        text += page.get_text()
    return text

original_file = '/content/drive/MyDrive/2407.19153v1.pdf' #모아둔 원본 파일 경로
  # 이건 위에서 reference 제거하기 전 수행해야 함
text = extract_text_from_pdf('/content/drive/MyDrive/2407.19153v1.pdf') # preprocessed 하위폴더에다가 저장


reference_section = re.compile(r'References\n')
reference_start_index = re.search(reference_section, text).span()

text_without_reference = text[:reference_start_index[0]]
text_without_reference = text_without_reference

input_string = text_without_reference
string_to_pdf(input_string, f'{original_file}.pdf')

''' # reference part deletion 작업, 일단 보류

# setup인데 잘 안돼서 위에서 직접 다운받음
'''#!/usr/bin/env python

try:
    from setuptools import setup
except ImportError:
    print('[libbmc] setuptools not found.')
    raise

with open('/content/drive/MyDrive/KISIA /프로젝트/__init__.py') as fh:
    for line in fh:
        if line.startswith('__version__'):
            version = line.strip().split()[-1][1:-1]
            break

#try:
    #from pip.req import parse_requirements
    #from pip.download import PipSession
#except ImportError:
    #print('[libbmc] pip not found.')
    #raise

# parse_requirements() returns generator of pip.req.InstallRequirement objects
parsed_requirements = parse_requirements("requirements.txt",
                                         session=PipSession())

# reqs is a list of requirement
# e.g. ['django==1.5.1', 'mezzanine==1.4.6']
install_requires = [str(ir.req) for ir in parsed_requirements]

setup(
    name='libbmc',
    version=version,
    url='https://github.com/Phyks/libbmc/',
    author='Phyks (Lucas Verney)',
    author_email='phyks@phyks.me',
    license='MIT License',
    description='A python library to deal with scientific papers.',
    packages=['libbmc',
              'libbmc.citations', 'libbmc.papers', 'libbmc.repositories'],
    install_requires=install_requires
)'''

text = cermine('/content/drive/MyDrive/2407.19153v1.pdf')
doi = cermine_dois('/content/drive/MyDrive/2407.19153v1.pdf')

reg_ref = re.compile(r'<ref-list>')
ref_start = reg_ref.search(text).span()
processed_text = text[:ref_start[0]]

processed_text



